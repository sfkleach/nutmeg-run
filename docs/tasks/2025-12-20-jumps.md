# Planting instructions for jumps

Labels are not resolved at compile time inside the bundle but dynamically
by the nutmeg-runtime. This is because static compilation of a jump requires
being able to calculate the size of instructions - but this is isolated to the
runtime (nuteg-run).

The instructions that we will initially meet are:

```json
        {
            "type": "if.not",
            "value": "L0"
        },
        {
            "type": "goto",
            "value": "L1"
        },
        {
            "type": "label",
            "value": "L0"
        },
```

## label

The label instruction is a target for other instructions. It does not itself
generate any instruction (although a subsequent instruction must exist!) The
parse_function_object function will need to map labels to instruction offsets.

If there are any offsets waiting to be resolved, this are updated now. (See
next section)

## goto value=LABEL

The L_GOTO instruction takes an offset that it adds to the virtual program
counter (`pc`) so that it points to the instruction labelled by LABEL. If the
label does not yet exist, which will be true for forward jumps, we have to 
save the location of the offset so that it can be updated when the label is
planted.

If the label does exist, which will be true for backward jumps or forward 
jumps to the same label, then we calculate the relative offset from the
`pc` to the destination, taking into account that the `pc` will already have
been advanced.

# if.not value=LABEL

The L_IF_NOT instruction is mechanically very similar to the L_GOTO insofar
that labels are resolved in the same way. However the transfer of control 
only happens if the top of the operand stack, which can be assumed to be 
non-empty, is SPECIAL_FALSE.